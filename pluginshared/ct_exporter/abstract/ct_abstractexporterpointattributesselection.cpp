#include "ct_abstractexporterpointattributesselection.h"

#include "ct_itemdrawable/ct_pointsattributescolor.h"
#include "ct_itemdrawable/ct_pointsattributesnormal.h"
#include "ct_itemdrawable/abstract/ct_abstractpointattributesscalar.h"
#include "ct_itemdrawable/tools/ct_itemsearchhelper.h"

#include "ct_model/tools/ct_modelsaverestorehelper.h"

CT_AbstractExporterPointAttributesSelection::CT_AbstractExporterPointAttributesSelection() : CT_AbstractExporterAttributesSelection()
{
}

bool CT_AbstractExporterPointAttributesSelection::configureExport()
{
    clearWorker();

    return selectAttributes();
}

CT_ItemDrawableHierarchyCollectionWidget::CloudType CT_AbstractExporterPointAttributesSelection::cloudType() const
{
    return CT_ItemDrawableHierarchyCollectionWidget::POINTS;
}

QList< QPair<QString, CT_AbstractItemDrawableCollectionBuilder*> > CT_AbstractExporterPointAttributesSelection::getBuilders() const
{
    QList< QPair<QString, CT_AbstractItemDrawableCollectionBuilder*> > l;
    l << QPair<QString, CT_AbstractItemDrawableCollectionBuilder*>(QObject::tr("Colors"), (CT_AbstractItemDrawableCollectionBuilder*)&m_attributsBuilderColors);
    l << QPair<QString, CT_AbstractItemDrawableCollectionBuilder*>(QObject::tr("Normals"), (CT_AbstractItemDrawableCollectionBuilder*)&m_attributsBuilderNormals);

    return l;
}

void CT_AbstractExporterPointAttributesSelection::postConfigureAttributesBuilder(CT_AbstractItemDrawableCollectionBuilder *builder)
{
    if((&m_attributsBuilderColors) == builder) {

        if(canExportWithColors())
            m_attributsBuilderColors.onlyKeepsTheseTypesInCollection2<CT_AttributesColor, CT_AbstractAttributesScalar>();
        else
            m_attributsBuilderColors.onlyKeepsTheseTypesInCollection1<CT_Nothing1>();

    } else if((&m_attributsBuilderNormals) == builder) {

        if(canExportWithNormals())
            m_attributsBuilderNormals.onlyKeepsTheseTypesInCollection1<CT_AttributesNormal>();
        else
            m_attributsBuilderNormals.onlyKeepsTheseTypesInCollection1<CT_Nothing1>();

    }
}

void CT_AbstractExporterPointAttributesSelection::setExcludeConfiguration(const QPair<QString, CT_AbstractItemDrawableCollectionBuilder *> &pair, CT_ItemDrawableHierarchyCollectionSelectionModel *model) const
{
    // if result is generated by the builder "m_attributsBuilderColors"
    if((&m_attributsBuilderColors) == pair.second) {
        //model->addExcludeModel(0); // exclude the selection of other colors founded by this builder. The index is 0 because it was the index of the builder in the "QList" of the method getBuilders()

        // if we can export with colors information
        if(canExportWithColors())
            model->addExcludeModel(-1); // exclude the selection of colors of the document
    }

    // if result is generated by the builder "m_attributsBuilderNormals"
    if((&m_attributsBuilderNormals) == pair.second) {
        //model->addExcludeModel(1); // exclude the selection of other normals founded by this builder. The index is 1 because it was the index of the builder in the "QList" of the method getBuilders()

        // if we can export with normals information
        if(canExportWithNormals())
            model->addExcludeModel(-2); // exclude the selection of normals of the document
    }
}

bool CT_AbstractExporterPointAttributesSelection::useSelection(const CT_ItemDrawableHierarchyCollectionWidget *selectorWidget)
{
    clearWorker();

    m_attributsColorPointWorker.setColorCloud(selectorWidget->colorCloudSelected());
    m_attributsNormalPointWorker.setNormalCloud(selectorWidget->normalCloudSelected());

    if(searchOnlyModels()) {

        QList<CT_OutAbstractSingularItemModel*> list = selectorWidget->itemDrawableModelSelected();
        QListIterator<CT_OutAbstractSingularItemModel*> it(list);

        while(it.hasNext())
        {
            CT_OutAbstractSingularItemModel *model = it.next();
            CT_AbstractItemDrawable *item = model->itemDrawable();
            CT_PointsAttributesColor *pac = dynamic_cast<CT_PointsAttributesColor*>(item);

            if(pac != NULL) {
                m_attributesColorModel.append(model);
            } else {
                CT_AbstractPointAttributesScalar *pas = dynamic_cast<CT_AbstractPointAttributesScalar*>(item);

                if(pas != NULL) {
                    m_attributesColorModel.append(model);
                } else {

                    CT_PointsAttributesNormal *pan = dynamic_cast<CT_PointsAttributesNormal*>(item);

                    if(pan != NULL)
                        m_attributesNormalModel.append(model);
                }
            }
        }

    } else {

        QList<CT_AbstractPointsAttributes*> attributesColor;
        QList<CT_AbstractPointsAttributes*> attributesNormal;

        QList<CT_AbstractSingularItemDrawable*> list = selectorWidget->itemDrawableSelected();
        QListIterator<CT_AbstractSingularItemDrawable*> it(list);

        while(it.hasNext())
        {
            CT_AbstractSingularItemDrawable *item = it.next();
            CT_PointsAttributesColor *pac = dynamic_cast<CT_PointsAttributesColor*>(item);

            if(pac != NULL) {
                attributesColor.append(pac);
            } else {
                CT_AbstractPointAttributesScalar *pas = dynamic_cast<CT_AbstractPointAttributesScalar*>(item);

                if(pas != NULL) {
                    attributesColor.append(pas);
                } else {

                    CT_PointsAttributesNormal *pan = dynamic_cast<CT_PointsAttributesNormal*>(item);

                    if(pan != NULL)
                        attributesNormal.append(pan);
                }
            }
        }

        m_attributsColorPointWorker.setAttributes(attributesColor);
        m_attributsNormalPointWorker.setAttributes(attributesNormal);
    }

    return true;
}

SettingsNodeGroup *CT_AbstractExporterPointAttributesSelection::saveExportConfiguration() const
{
    CT_ModelSaveRestoreHelper helper;

    SettingsNodeGroup *root = CT_AbstractExporterAttributesSelection::saveExportConfiguration();

    SettingsNodeGroup *myRoot = new SettingsNodeGroup("CT_AbstractExporterPointAttributesSelection");

    if(!m_attributesColorModel.isEmpty())
    {
        QListIterator< CT_OutAbstractSingularItemModel* > it(m_attributesColorModel);

        while(it.hasNext())
        {
            CT_OutAbstractSingularItemModel *model = it.next();

            SettingsNodeGroup *node = helper.saveToSearchOutModel(model, "ColorModel");

            myRoot->addGroup(node);
        }
    }

    if(!m_attributesNormalModel.isEmpty())
    {
        QListIterator< CT_OutAbstractSingularItemModel* > it(m_attributesNormalModel);

        while(it.hasNext())
        {
            CT_OutAbstractSingularItemModel *model = it.next();

            SettingsNodeGroup *node = helper.saveToSearchOutModel(model, "NormalModel");

            myRoot->addGroup(node);
        }
    }

    root->addGroup(myRoot);

    return root;
}

bool CT_AbstractExporterPointAttributesSelection::loadExportConfiguration(const SettingsNodeGroup *root)
{
    clearWorker();

    if(CT_AbstractExporterAttributesSelection::loadExportConfiguration(root))
    {
        CT_ModelSaveRestoreHelper helper;

        QList<SettingsNodeGroup*> groups = root->groupsByTagName("CT_AbstractExporterPointAttributesSelection");

        if(groups.isEmpty())
            return true;

        // load colors model
        QList<SettingsNodeGroup*> colorsGroup = groups.first()->groupsByTagName("ColorModel");

        foreach (SettingsNodeGroup *node, colorsGroup) {
            CT_OutAbstractSingularItemModel *model = dynamic_cast<CT_OutAbstractSingularItemModel *>(helper.searchModelFromSettings(node, myStep()));

            if(model != NULL)
                m_attributesColorModel.append(model);
        }

        // load normals model
        QList<SettingsNodeGroup*> normalsGroup = groups.first()->groupsByTagName("NormalModel");

        foreach (SettingsNodeGroup *node, normalsGroup) {
            CT_OutAbstractSingularItemModel *model = dynamic_cast<CT_OutAbstractSingularItemModel *>(helper.searchModelFromSettings(node, myStep()));

            if(model != NULL)
                m_attributesNormalModel.append(model);
        }

        return (colorsGroup.size() == m_attributesColorModel.size()) && (normalsGroup.size() == m_attributesNormalModel.size());
    }

    return false;
}

CT_AbstractColorCloud* CT_AbstractExporterPointAttributesSelection::createColorCloudBeforeExportToFile()
{
    CT_AbstractColorCloud *cc = NULL;

    // if we have saved models for attributes of type colors we must search the real item drawable that match with this model
    if(!m_attributesColorModel.isEmpty()) {
        QList<CT_AbstractPointsAttributes*> attributesColor;

        CT_ItemSearchHelper helper;

        QListIterator<CT_OutAbstractSingularItemModel*> itM(m_attributesColorModel);

        while(itM.hasNext()) {
            CT_ResultItemIterator it = helper.searchSingularItemsForModel(itM.next());

            if(it.hasNext()) {
                CT_AbstractSingularItemDrawable *item = (CT_AbstractSingularItemDrawable*)it.next();

                if((dynamic_cast<CT_PointsAttributesColor*>(item) != NULL)
                        || (dynamic_cast<CT_AbstractPointAttributesScalar*>(item)))
                    attributesColor.append(dynamic_cast<CT_AbstractPointsAttributes*>(item));
            }
        }

        m_attributsColorPointWorker.setAttributes(attributesColor);
    }

    if((m_attributsColorPointWorker.colorCloud().data() == NULL)
            && (!m_attributsColorPointWorker.attributes().isEmpty()))
    {
        m_attributsColorPointWorker.setColorCloud(PS_REPOSITORY->createNewColorCloud(CT_Repository::SyncWithPointCloud));
        m_attributsColorPointWorker.apply();
        cc = m_attributsColorPointWorker.colorCloud()->abstractColorCloud();
    }
    else if(m_attributsColorPointWorker.colorCloud().data() != NULL)
    {
        cc = m_attributsColorPointWorker.colorCloud()->abstractColorCloud();
    }

    return cc;
}

CT_AbstractNormalCloud* CT_AbstractExporterPointAttributesSelection::createNormalCloudBeforeExportToFile()
{
    CT_AbstractNormalCloud *nc = NULL;

    // if we have saved models for attributes of type colors we must search the real item drawable that match with this model
    if(!m_attributesNormalModel.isEmpty()) {
        QList<CT_AbstractPointsAttributes*> attributesNormal;

        CT_ItemSearchHelper helper;

        QListIterator<CT_OutAbstractSingularItemModel*> itM(m_attributesNormalModel);

        while(itM.hasNext()) {
            CT_ResultItemIterator it = helper.searchSingularItemsForModel(itM.next());

            if(it.hasNext()) {
                CT_AbstractSingularItemDrawable *item = (CT_AbstractSingularItemDrawable*)it.next();

                if(dynamic_cast<CT_PointsAttributesNormal*>(item) != NULL)
                    attributesNormal.append(dynamic_cast<CT_AbstractPointsAttributes*>(item));
            }
        }

        m_attributsNormalPointWorker.setAttributes(attributesNormal);
    }

    if((m_attributsNormalPointWorker.normalCloud().data() == NULL)
            && (!m_attributsNormalPointWorker.attributes().isEmpty()))
    {
        m_attributsNormalPointWorker.setNormalCloud(PS_REPOSITORY->createNewNormalCloud(CT_Repository::SyncWithPointCloud));
        m_attributsNormalPointWorker.apply();
        nc = m_attributsNormalPointWorker.normalCloud()->abstractNormalCloud();
    }
    else if(m_attributsNormalPointWorker.normalCloud().data() != NULL)
    {
        nc = m_attributsNormalPointWorker.normalCloud()->abstractNormalCloud();
    }

    return nc;
}

void CT_AbstractExporterPointAttributesSelection::clearWorker()
{
    m_attributsColorPointWorker.setAttributes(QList<CT_AbstractPointsAttributes*>());
    m_attributsColorPointWorker.setColorCloud(QSharedPointer<CT_StandardColorCloudRegistered>(NULL));

    m_attributsNormalPointWorker.setAttributes(QList<CT_AbstractPointsAttributes*>());
    m_attributsNormalPointWorker.setColorCloud(QSharedPointer<CT_StandardColorCloudRegistered>(NULL));

    m_attributesColorModel.clear();
    m_attributesNormalModel.clear();
}
